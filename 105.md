1. 排序算法中常以交换的方式进行，交换代表某一个数字和某一个数字互换位置，例如给定一数列 $\texttt{5  3  2  4  1}$，我们想要将此数列从小到大排序，若不做重复的交换的话(同一个数字不能和另一个数字做两次以上的交换)，则至少要交换两次：

（目　标）$\texttt{1 2 3 4 5}$  
（初始值）$\texttt{5 3 2 4 1}$  
（第一次）$\texttt{1 3 2 4 5}$ 交换 $\texttt{(1,5)}$  
（第二次）$\texttt{1 2 3 4 5}$ 交换 $\texttt{(2,3)}$

若要将数列 $\texttt{5 7 6 1 4 3 2}$ 进行排序（小到大），且不做重复的交换，最少交换几次后后即可完成排序?

a. 3  
b. 4  
c. 5  
d. 6

2. 利用较有效率的方法计算下列多项式时，总共需要几个加、减、乘法的运算？  
$$f(x) = 2x^4 + 3x^3 − 3x^2 + 5x − 1$$

a. 14  
b. 12  
c. 11  
d. 8

3. 给定下列物品清单，若卡车载重上限为 3500，请问最多可搬移多少价值的物品？

|重量|815|906|127|914|633|98|279|
|-|-|-|-|-|-|-|-|
|价值|547|958|965|158|971|958|486|

a. 5043  
b. 4885  
c. 4496  
d. 4072

4. 在图中，→ 表示机器人起点位置且为目前面对的方向， 机器人需要走到标注 ❤ 的位置。

![Snipaste_2018-10-09_15-53-29.png](https://i.loli.net/2018/10/09/5bbc5e66b3054.png)

控制机器人的指令有两个：
* `CAN_MOVE(方向)` 检查并回传是否可往「方向」前进  
* `MOVE(方向)` 表示往「方向」转后前进一步。

例如 `CAN_MOVE(FORWARD)` 即回传是否可往现在面对的方向前进一步；而 `MOVE(LEFT)` 则会让机器人左转并往前推进一步。
```
REPEAT UNTIL (Goal(❤))
{
  IF CAN_MOVE( 方向A ) MOVE( 方向A )
  IF CAN_MOVE( 方向B ) MOVE( 方向B )
  IF CAN_MOVE( 方向C ) MOVE( 方向C )
}
```
该程序会反复执行。请问： `方向 A` 、`方向 B` 、 `方向 C` 应该分别设成什么，才可以让机器人以最短的路径走到 ❤ 的位置?

a. `FORWARD`, `LEFT`, `RIGHT`  
b. `RIGHT`, `FORWARD`, `LEFT`  
c. `LEFT`, `FORWARD`, `RIGHT`  
d. `LEFT`, `RIGHT`, `FORWARD`

5. 小城镇中的电车路线图如下，其中 A, B, C 和 D 表示四个站，单一箭头的连接线表示电车从端点为起站开向有箭头端的终站；双箭头的连接线表示两端点的站之间双向都有电车互通。

![clip_image004.gif](https://i.loli.net/2018/10/09/5bbc5ed50b4c5.gif)

若以一个二维数组 `Map[i][j]` 来记录这个电车路线图，`Map[i][j]=1` 表示从站 $i$ 到站 $j$ 有一条电车路线，否则 `Map[i][j]=0`。请问下列哪几个数组可以用以表示右侧电车路线图？

|[1]|[2]|[3]|[4]|
|-|-|-|-|
|0 0 0 0 <br> 1 0 1 0 <br> 0 1 0 1 <br> 1 1 1 0|0 1 0 0 <br> 1 0 1 1 <br> 0 1 0 0 <br> 1 0 1 0|0 1 1 1 <br> 1 0 0 1 <br> 0 0 0 0 <br> 0 1 1 0|0 0 0 0 <br> 1 0 1 1 <br> 0 1 0 1 <br> 1 1 0 0|

a. 只有数组 [1] 是可能的
b. 只有数组 [1] 跟 [3] 是可能的
c. 只有数组 [1] 跟 [4] 是可能的
d. 只有数组 [2] 跟 [3] 是可能的

6. $e^x$ 的近似解可用下列式子表示：

$$e^x=1+\cfrac{x}{1!}+\cfrac{x^2}{2!}+\dots++\cfrac{x^{10}}{10!}$$

请在下划线处带入正确的式子，使该程序能正确计算 $e^x$。

```c
scanf(“%d”,  &x);
sum=1;
n=0;
t=1;
while (n<10) {
  n++;
  t*=n;
  sum=________
}
printf(“e^x = %d”, sum);
```

a. `sum+x^n/t`  
b. `sum+x^t/n`  
c. `sum+x*t/n`  
d. `sum+x/t*n`

7. `array` 长度为 $n$。该程序拟将数组 `array` 的元素进行升幂排序，请问下划线处要填入哪个式子，才能使之正确排序？
```c
for (int i=0; i < n-1; i++){
  for (int j=0; j < (a) ; j++){
    if (array[j+1] < array[j]){
      int temp = array[j];
      array[j] = array[j+1];
      array[j+1] = temp;
    }
  }
}
```

a. `n`  
b. `n - i`  
c. `n – i - 1`  
d. `n - 1`

8. `f(10)` 的返回值为________
```c
int f(int n) {
  if (n<=3) return 1;
  return f(n-1)+f(n-2)+f(n-3);
}
```

a. 55  
b. 57  
c. 105  
d. 193

9.   
```c
x = 1;
y = 10;
for (int i=1; i<=2; i++)
  x = x + x;
for (int i=1; i<=2; i++)
  x = x * x;
y = x; x = y;
printf (“%d\n”, x); 
```
该程序片段输出为________

a. 4  
b. 10  
c. 16  
d. 256

10. 
```c
int x=0, y=10; // 全局变量
int swap(int x, int y) {
  int temp = x;
  x = y;
  y = temp;
  return 0;
}
int main() {
  int x=5, ans=0;
  ans += x;
  swap(x, y);
  ans += y;
  printf(“%d\n”, ans);
  return 0;
}
```
该程序片段输出为________

a. 0  
b. 5  
c. 10  
d. 15

11. 给定 `adjust()` 函式及数组 `a[]` 的内容如下：
```c
void adjust (int a[], int root, int n) {
  int child, rootkey;
  int temp;
  temp = a[root];
  rootkey = a[root];
  child = 2 * root;
  while (child <= n) {
    if ((child < n) && (a[child] < a[child+1]))
      child++;
      if (rootkey > a[child])
        break;
      else {
        a[child/2] = a[child];
        child *= 2;
      }
  }
  a[child/2] = temp;
}
```

|$i$|1|2|3|4|5|6|7|8|9|10|
|-|-|-|-|-|-|-|-|-|-|-|
|`a[i]`|26|5|77|1|61|11|59|15|48|19|

若 $n=10$，则执行以下 `for` 循环之后，`a[5]` = ________
``` c
for (i=n/2; i>0; i--) adjust(a, i, n);
```

a. 11  
b. 19  
c. 26  
d. 61


